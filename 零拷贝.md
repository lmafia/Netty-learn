# IO中的零拷贝

## 内存的用户空间和内核空间

内存中有用户空间提供给用户调用

内存中内核空间给操作系统的指令使用

## DMA

DMA:直接存储访问，即不会经过CPU的运算，直接由DMA总线进行拷贝

当我们执行`read(new byte[10])`时，发送的调用过程

![image-20210422073059921](https://cdn.jsdelivr.net/gh/lmafia/private-picture-could@master/20210422073100.png)

## 上下文切换

是指CPU执行用户进程执行时处于用户态，当用户进程调用系统函数时，CPU中断用户执行，切换为内核态，执行系统指令。



## 普通的文件传输方式

普通的方式需要4次上下文切换、2次DMA拷贝、2次CPU运算拷贝

![image-20210427003842615](https://cdn.jsdelivr.net/gh/lmafia/private-picture-could@master/20210427003842.png)

## 内存映射(MMAP)方式

MMAP的方式就在CPU拷贝上做了一次优化，把内核的内存空间进行映射，映射到内存的用户空间上，这样对用户空间的操作实际是在对内核空间做操作。

![image-20210427011412869](https://cdn.jsdelivr.net/gh/lmafia/private-picture-could@master/20210427011412.png)

## Linux的sendFile()优化
### Linux2.1的方式
`sendFile()`为Linux2.1后增加的系统函数，sendfile系统调用的引入，不仅减少了数据复制，还减少了上下文切换的次数
### Linux2.4的方式

这还不是最后效果呢，Linux为了消除内核产生的数据冗余，就是CPU拷贝会产生一些数据副本，提出了一个可以在多块内存空间发拷贝给网卡，所以需要网卡支持聚合操作特性。这个特性意味着待发送的数据可以不用存在地址连续的内存空间中，可以分散存放。

具体做法是在内核版本2.4中，socket缓冲区描述符结构发生了改动，以适应聚合操作的要求——这就是Linux中所谓的"零拷贝“。这种方式不仅减少了多个上下文切换，而且消除了数据冗余。

所以提升的要求有2

1. 支持聚合操作的硬件可以从多个内存位置收集数据，从而消除另一个副本。
2. Linux对socket的缓冲区描述符进行改动，以支持聚合操作

![image-20210427074825998](https://cdn.jsdelivr.net/gh/lmafia/private-picture-could@master/20210427074826.png)